"""nbscholar (new-big scholar, å¤§ç‰›å­¦è€…) is a extension for better NoteBook development, extending fastai's `nbdev` libary. It is designed to assist you become a New-Big (a.k.a. ç‰›é€¼ or awesome) scholar one day."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../src/notebooks/03_nbscholar (nbdev extensions).ipynb.

# %% auto 0
__all__ = [
    "functions",
    "read_settings_ini_none",
    "functions_dict",
    "nbscholar_submodules_to_ssh",
    "nbscholar_submodules",
    "check_ipynb_file",
    "check_directory",
    "nbscholar_check",
    "read_settings_ini",
    "nbscholar_export",
    "guess_notebooks_path",
    "split_import_and_code_cells",
    "operate_on_notebook_in",
    "process_notebooks_in_folder",
    "nbscholar_separate",
    "nbscholar",
]

# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 4
from fastcore.script import call_parse

# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 5
functions = []

# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 7
import re
import subprocess
from pathlib import Path
from .logging.nucleus import logger
from fastcore.script import call_parse


@call_parse
def nbscholar_submodules_to_ssh(path: str = "."):
    """
    Convert all HTTPS submodule URLs in `.gitmodules` to SSH URLs (e.g. https://github.com/user/repo.git â†’ git@github.com:user/repo.git)
    """

    gitmodules = Path(path) / ".gitmodules"
    if not gitmodules.exists():
        logger.error(
            "âŒ æœªæ‰¾åˆ° .gitmodules æ–‡ä»¶ï¼Œè¯·åœ¨å«æœ‰å­æ¨¡å—çš„é¡¹ç›®æ ¹ç›®å½•è¿è¡Œæ­¤å‡½æ•°ã€‚"
        )
        raise FileNotFoundError(".gitmodules not found")

    content = gitmodules.read_text(encoding="utf-8")

    # åŒ¹é… https://github.com/user/repo(.git)
    pattern = re.compile(r"https://([^/]+)/([^/]+)/([^/\n]+)(\.git)?")

    changed = False

    def https_to_ssh(match):
        nonlocal changed
        host, user, repo, dotgit = match.groups()
        ssh_url = f"git@{host}:{user}/{repo}.git"
        logger.info(f"ğŸ” è½¬æ¢: https://{host}/{user}/{repo} â†’ {ssh_url}")
        changed = True
        return ssh_url

    new_content = pattern.sub(https_to_ssh, content)

    if changed:
        gitmodules.write_text(new_content, encoding="utf-8")
        logger.success("âœ… å·²æ›´æ–° .gitmodules æ–‡ä»¶ä¸­çš„ URLã€‚")

        # åŒæ­¥å­æ¨¡å—é…ç½®
        res = subprocess.run(["git", "submodule", "sync", "--recursive"])
        if res.returncode == 0:
            logger.success("âœ… å·²æ‰§è¡Œ `git submodule sync --recursive`ã€‚")
        else:
            logger.warning("âš ï¸ `git submodule sync` æ‰§è¡Œå¤±è´¥ï¼Œè¯·æ‰‹åŠ¨æ£€æŸ¥ã€‚")
    else:
        logger.info("â„¹ï¸ æ²¡æœ‰å‘ç° HTTPS æ ¼å¼çš„å­æ¨¡å— URLï¼Œæ— éœ€ä¿®æ”¹ã€‚")


# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 8
@call_parse
def nbscholar_submodules(mode: str = "to_ssh", *args, **kwargs):
    if mode == "to_ssh":
        nbscholar_submodules_to_ssh(*args, **kwargs)
    else:
        raise ValueError(f"Unknown mode: {mode}")


functions.append(nbscholar_submodules)

# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 13
import json
import ast
import os
import argparse
from pathlib import Path
from .logging.nucleus import logger


def check_ipynb_file(filepath):
    """
    Check a single ipynb file for Python syntax errors in code cells.
    Returns True if no errors, False otherwise.
    """
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            notebook = json.load(f)
    except json.JSONDecodeError as e:
        logger.error(f"âŒ {filepath} - Invalid JSON: {e}")
        return False

    if "cells" not in notebook:
        logger.warning(f"âš ï¸  {filepath} - No 'cells' key found (malformed notebook)")
        return True  # Not a syntax error in code, skip

    errors_found = False

    for cell_idx, cell in enumerate(notebook["cells"], start=1):
        if cell["cell_type"] != "code":
            continue  # Skip non-code cells

        # Join source lines into a single string
        code = "".join(cell["source"])
        if not code.strip():
            continue  # Skip empty code cells

        try:
            # Check for syntax errors using ast.parse
            ast.parse(code)
        except SyntaxError as e:
            errors_found = True
            logger.error(f"\nâŒ {filepath}")
            logger.error(f"   Cell {cell_idx}, Line {e.lineno}, Column {e.offset}")
            logger.error(
                f"   Problematic code: {e.text.strip() if e.text else 'Unknown'}"
            )
            logger.exception(e)

    if not errors_found:
        logger.info(f"âœ… {filepath} - No syntax errors found")
    return not errors_found


# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 14
from .logging.nucleus import logger


def check_directory(dirpath):
    """
    Check all ipynb files in a directory (and subdirectories) for syntax errors.
    Returns True if all files are error-free, False otherwise.
    """
    all_ok = True
    file_count = 0
    error_count = 0

    dir_path = Path(dirpath)
    # ä½¿ç”¨rglobé€’å½’æŸ¥æ‰¾æ‰€æœ‰ipynbæ–‡ä»¶
    for filepath in dir_path.rglob("*.ipynb"):
        file_count += 1
        if not check_ipynb_file(str(filepath)):
            error_count += 1
            all_ok = False

    logger.info("\n--- Summary ---")
    logger.info(f"Checked {file_count} .ipynb files")
    logger.info(f"Found errors in {error_count} files")
    logger.info(f"All files syntax error-free: {'Yes' if all_ok else 'No'}")
    return all_ok


# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 15
from fastcore.script import call_parse


@call_parse
def nbscholar_check(
    target_path: str = ".",  # Path to .ipynb file or directory containing .ipynb files
):
    """
    Check .ipynb files for severe Python syntax errors (indent, missing colons/comma, etc.)
    """
    if not os.path.exists(target_path):
        raise FileNotFoundError(f"âŒ Path does not exist: {target_path}")

    if os.path.isfile(target_path):
        if not target_path.endswith(".ipynb"):
            raise ValueError(f"âŒ Not a .ipynb file: {target_path}")
        check_ipynb_file(target_path)
    else:
        check_directory(target_path)


functions.append(nbscholar_check)

# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 17
import configparser
import os
from pathlib import Path


# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 18
# from skinfra.experiment import load_overlaying_config
def read_settings_ini(
    directory: str, item="nbs_path", track="DEFAULT", ini_name="settings.ini"
):
    # return load_overlaying_config(
    #     directory, ini_name
    # )[track][item]
    config = configparser.ConfigParser()
    # é€çº§å‘ä¸ŠæŸ¥æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ªåŒ…å« settings.ini çš„ç›®å½•
    current = directory

    while True:
        settings_path = os.path.join(current, ini_name)
        if os.path.exists(settings_path):
            break
        parent = os.path.dirname(current)
        if parent == current:  # å·²åˆ°è¾¾æ ¹ç›®å½•
            raise FileNotFoundError(
                f"Could not find {ini_name} in any parent of {directory}"
            )
        current = parent

    config.read(settings_path)
    assert track in config, f"Could not find {track} in {settings_path}"
    assert item in config[track], f"Could not find {item} in {settings_path}"
    return config[track][item]


# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 19
import subprocess
import os
from .logging.nucleus import logger


@call_parse
def nbscholar_export(path: str = "."):
    res = os.system("nbdev_export")
    if res != 0:
        logger.error(
            "nbdev_export failed, now I will use `nbscholar_check` to help you locate the error. "
        )
        nbscholar_check(path)
        raise Exception("nbdev_export failed")
    # è¯»å– settings.ini çš„ lib_path
    lib_path = read_settings_ini(path, item="lib_path")

    # MKINIT ç”Ÿæˆ __init__.py
    # res = os.system(f"mkinit {lib_name} -w --lazy_loader --recursive --relative")
    res = os.system(f"mkinit {lib_path} -w --lazy_loader_typed --recursive --relative")
    if res != 0:
        # raise Exception("mkinit failed")
        logger.warning("mkinit failed")

    # RUFF æ ¼å¼åŒ–
    res = os.system(f"ruff format {lib_path}")
    if res != 0:
        logger.warning("ruff format failed")


functions.append(nbscholar_export)


# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 23
import os
import nbformat
import re
from nbformat.notebooknode import NotebookNode, from_dict
from . import default_on_exception

# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 24
read_settings_ini_none = default_on_exception(read_settings_ini, default_value=None)


def guess_notebooks_path(directory="."):
    if isinstance(directory, Path):
        directory = directory.as_posix()
    # è¯»å– setting.ini çš„ nbs_pathï¼Œ å¦‚æœæœ‰çš„è¯ï¼Œæ²¡æœ‰å°±è¿”å›None
    return read_settings_ini_none(directory)


# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 27
from copy import deepcopy


# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 28
def split_import_and_code_cells(notebook, inplace=True):
    """
    Process a Jupyter Notebook file, splitting cells with both import and non-import lines into two cells.
    The first new cell will contain only import statements, and the second will contain the rest of the code.
    """
    notebook = notebook if inplace else deepcopy(notebook)

    new_cells = []

    for cell in notebook["cells"]:
        if cell["cell_type"] == "code":
            # Split the lines in the cell
            lines = cell["source"].splitlines()

            # Extract leading blank lines or lines starting with "#|"
            leading_lines = []
            while lines and (lines[0].strip() == "" or lines[0].startswith("#|")):
                leading_lines.append(lines.pop(0))

            # Separate import statements and other code lines
            import_lines = [
                line for line in lines if re.match(r"^\s*import\b|^\s*from\b", line)
            ]
            other_lines = [line for line in lines if line not in import_lines]

            if import_lines and other_lines:
                # Add the leading lines to the import cell

                new_cells.append(
                    from_dict(
                        cell
                        | {
                            "cell_type": "code",
                            "metadata": {},
                            "source": "\n".join(leading_lines + import_lines),
                            "outputs": [],
                        }
                    )
                )
                # Add the leading lines to the other code cell
                new_cells.append(
                    from_dict(
                        cell
                        | {
                            "cell_type": "code",
                            "metadata": {},
                            "source": "\n".join(leading_lines + other_lines),
                            "outputs": cell["outputs"],
                        }
                    )
                )
            else:
                # If no split is needed, retain the original cell
                new_cells.append(cell)
        else:
            # Retain non-code cells as is
            new_cells.append(cell)

    # Update the notebook with the modified cells
    notebook["cells"] = new_cells
    return notebook


# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 30
def operate_on_notebook_in(
    input_path, output_path=None, operation=split_import_and_code_cells
):
    if output_path is None:
        output_path = input_path
    with open(input_path, "r", encoding="utf-8") as f:
        notebook = nbformat.read(f, as_version=4)
    notebook = operation(notebook)
    # Save the modified notebook
    with open(output_path, "w", encoding="utf-8") as f:
        nbformat.write(notebook, f)


# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 31
def process_notebooks_in_folder(folder_path, operation=split_import_and_code_cells):
    """
    Traverse all .ipynb files in a folder and apply the cell-splitting logic.
    """
    if isinstance(folder_path, Path):
        folder_path = folder_path.as_posix()
    for root, _, files in os.walk(folder_path):
        for file in files:
            if file.endswith(".ipynb"):
                notebook_path = os.path.join(root, file)
                print(f"Processing {notebook_path}")
                operate_on_notebook_in(notebook_path, operation=operation)


# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 32
@call_parse
def nbscholar_separate(path: str = "."):
    if os.path.isfile(path):
        return operate_on_notebook_in(path, split_import_and_code_cells)

    notebook_path = guess_notebooks_path(path)
    if notebook_path is None:
        notebook_path = path
    process_notebooks_in_folder(notebook_path)


functions.append(nbscholar_separate)

# %% ../src/notebooks/03_nbscholar (nbdev extensions).ipynb 34
functions_dict = {v.__name__.replace("nbscholar_", ""): v for v in functions}


# æ•´ä½“è·¯ç”±
@call_parse
def nbscholar(mode: str = "export", *args, **kwargs):
    function = functions_dict.get(mode, None)
    if function is None:
        raise ValueError(f"Invalid mode: {mode}")
    function(*args, **kwargs)
